import os
import logging
import boto3
from botocore.exceptions import ClientError
from slack_bolt import App
from slack_bolt.adapter.aws_lambda import SlackRequestHandler

logger = logging.getLogger()
logger.setLevel(logging.INFO)

app = App(
    token=os.environ.get("SLACK_BOT_TOKEN"),
    signing_secret=os.environ.get("SLACK_SIGNING_SECRET"),
    process_before_response=True,
)


def remove_bot_mention(message_text, bot_user_id):
    mention = f"<@{bot_user_id}>"
    logger.info(f"Original message text: {message_text}")
    logger.info(f"Bot user ID: {bot_user_id}")
    logger.info(f"Mention to remove: {mention}")

    updated_message_text = message_text.replace(mention, "").strip()
    logger.info(f"Updated message text: {updated_message_text}")

    return updated_message_text


def invoke_model(messages):
    """
    Invokes a bedrock model using the provided messages.

    Args:
        messages (list): A list of messages to be sent to the model.

    Returns:
        str: The output text generated by the model.

    """
    client = boto3.client("bedrock-runtime")
    modelId = os.environ.get("BEDROCK_MODEL_ID")

    try:
        logger.info(f"Invoking bedrock model: {modelId}")

        response = client.converse(
            modelId=modelId,
            messages=messages,
            system=[{"text": "Respond using Slack flavored Markdown formatting."}],
        )

        output_text = ""
        for content in response["output"]["message"]["content"]:
            output_text += content["text"]

        logger.info(f"Model response: {output_text}")

        token_usage = response["usage"]
        logger.info(f"Input tokens: {token_usage['inputTokens']}")
        logger.info(f"Output tokens: {token_usage['outputTokens']}")
        logger.info(f"Total tokens: {token_usage['totalTokens']}")
        logger.info(f"Stop reason: {response['stopReason']}")

        return output_text

    except (ClientError, Exception) as e:
        logging.error(f"ERROR: Can't invoke '{modelId}'. Reason: {e}")
        raise e


def respond_to_slack_within_3_seconds(body, ack):
    ack()
    logger.debug(body)


def handle_app_mention(say, body):
    """
    Handle the event when the Slack app is mentioned in a message.

    Args:
        say (callable): A function provided by the Slack API to send a response message.
        body (dict): The event data received from Slack, containing information about the mention.

    Returns:
        None

    Raises:
        Exception: If an error occurs while processing the message or invoking the model.

    This function performs the following steps:
    1. Retrieves the bot user ID, channel ID, message text, and thread timestamp from the event data.
    2. Removes the bot mention from the message text.
    3. Invokes the model with the user's message.
    4. Posts the model's response to the Slack channel.
    5. Logs any errors that occur during the process.
    """

    bot_user_id = app.client.auth_test()["user_id"]
    channel_id = body["event"]["channel"]
    message_text = body["event"]["text"]
    thread_ts = body["event"]["ts"]

    mention = f"<@{bot_user_id}>"
    message = message_text.replace(mention, "").strip()

    logger.info(f"Channel ID: {channel_id}")
    logger.info(f"Thread TS: {thread_ts}")

    try:
        messages = [{"role": "user", "content": [{"text": message}]}]
        logger.info(f"Invoking model with messages: {messages}")

        model_response = invoke_model(messages)

        say(model_response, thread_ts=thread_ts)
        logger.info(f"Posted response to channel: {channel_id}")

    except Exception as e:
        logger.error(f"An error occurred while processing the message: {str(e)}")
        say(text=f"Error: {str(e)}", thread_ts=thread_ts)


app.event("app_mention")(
    ack=respond_to_slack_within_3_seconds, lazy=[handle_app_mention]
)


def handle_message(body, say):
    logger.debug(body)

    event = body["event"]
    thread_ts = event.get("thread_ts")
    bot_id = app.client.auth_test()["bot_id"]
    channel = event["channel"]

    if not thread_ts:
        logger.info("Message is not part of a thread. Skipping processing.")
        return

    conversation_history = app.client.conversations_replies(
        channel=channel,
        ts=thread_ts,
        limit=100,
    )

    bot_responded_earlier = any(
        message.get("bot_id") == bot_id for message in conversation_history["messages"]
    )

    if not bot_responded_earlier:
        logger.info("Bot has not responded earlier in the thread. Skipping processing.")
        return

    messages = []
    for message in conversation_history["messages"]:
        if message.get("bot_id") == bot_id:
            messages.append(
                {"role": "assistant", "content": [{"text": message["text"]}]}
            )
        elif message.get("user"):
            messages.append({"role": "user", "content": [{"text": message["text"]}]})

    try:
        logger.info(f"Invoking model with messages: {messages}")

        model_response = invoke_model(messages)

        say(model_response, thread_ts=thread_ts)

    except Exception as e:
        logger.error(f"ERROR: occurred while processing message: {str(e)}")
        say(text=f"Error: {str(e)}", thread_ts=thread_ts)


app.event("message")(ack=respond_to_slack_within_3_seconds, lazy=[handle_message])


@app.event("app_home_opened")
def handle_app_home_opened(client, event, logger):
    try:
        client.views_publish(
            user_id=event["user"],
            view={
                "type": "home",
                "callback_id": "home_view",
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "*Welcome to Bedrock!* :bed: :rock:",
                        },
                    },
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "I'm here to help you interact with cutting edge AI models from leaders in the space without ever leaving the comfort of Slack!",
                        },
                    },
                    {"type": "divider"},
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "Currently supported models: https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference.html#conversation-inference-supported-models-features",
                        },
                    },
                ],
            },
        )

    except Exception as e:
        logger.error(f"ERROR: publishing home tab: {e}")


@app.error
def custom_error_handler(error, body):
    logger.exception(f"Error: {error}")
    logger.info(f"Request body: {body}")


def lambda_handler(event, context):
    slack_handler = SlackRequestHandler(app=app)
    return slack_handler.handle(event, context)
